inv <- x["getinv"]
print("line 2")
if(!is.null(inv)){
message("gettiy = ng cached data")
return(inv)
}
data <- x["get"]
inv <- solve(data,...)
x$setinv(inv)
inv
}
x
cacheSolve(y)
cacheSolve(y)
cacheSolve(y)
y = matrix(c(2:5),2,2)
y
cacheSolve(y)
## Put comments here that give an overall description of what your
## functions do
## creating the special matrix whose inverse will be cached
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y){
x <<- y
inv <<- NULL
}
get <- function() x
setinv <- function(solve) inv <<- solve
getinv <- function() inv
list(set=set, get=get,setinv=setinv, getinv=getinv)
}
## If the same matrix is supplied, we will look up the cache and retrieve
## the value of inverse from the cache
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
print("line 1")
inv <- x["getinv"]
print("line 2")
if(!is.null(inv)){
message("getting cached data")
return(inv)
}
data <- x["get"]
inv <- solve(data,...)
x$setinv(inv)
inv
}
cacheSolve(y)
## Put comments here that give an overall description of what your
## functions do
## creating the special matrix whose inverse will be cached
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
##set is just setting value for the matrix not it's inv
set <- function(y){
x <<- y
inv <<- NULL
}
get <- function() x
## setting the inverse of the matrix
setinv <- function(solve) inv <<- solve
getinv <- function() inv
list(set=set, get=get,setinv=setinv, getinv=getinv)
}
## If the same matrix is supplied, we will look up the cache and retrieve
## the value of inverse from the cache
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x[["getinv"]]
if(!is.null(inv)){
message("getting cached data")
return(inv)
}
data <- x["get"]
inv <- solve(data,...)
x$setinv(inv)
inv
}
x
y <- x
y
x
makeCacheMatrix(x)
cacheSolve(x)
## Put comments here that give an overall description of what your
## functions do
## creating the special matrix whose inverse will be cached
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
##set is just setting value for the matrix not it's inv
set <- function(y){
x <<- y
inv <<- NULL
}
get <- function() x
## setting the inverse of the matrix
setinv <- function(solve) inv <<- solve
getinv <- function() inv
list(set=set, get=get,setinv=setinv, getinv=getinv)
}
## If the same matrix is supplied, we will look up the cache and retrieve
## the value of inverse from the cache
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x["getinv"]
if(!is.null(inv)){
message("getting cached data")
return(inv)
}
data <- x["get"]
inv <- solve(data,...)
x$setinv(inv)
inv
}
cacheSolve(x)
rm(cachemean)
rm(cacheSolve,makeCacheMatrix,makeVector,x,y)
## Put comments here that give an overall description of what your
## functions do
## creating the special matrix whose inverse will be cached
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
##set is just setting value for the matrix not it's inv
set <- function(y){
x <<- y
inv <<- NULL
}
get <- function() x
## setting the inverse of the matrix
setinv <- function(solve) inv <<- solve
getinv <- function() inv
list(set=set, get=get,setinv=setinv, getinv=getinv)
}
## If the same matrix is supplied, we will look up the cache and retrieve
## the value of inverse from the cache
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x["getinv"]
if(!is.null(inv)){
message("getting cached data")
return(inv)
}
data <- x["get"]
inv <- solve(data,...)
x$setinv(inv)
inv
}
cacheSolve(matrix(c(1:4,2,2)))
## Put comments here that give an overall description of what your
## functions do
## creating the special matrix whose inverse will be cached
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
##set is just setting value for the matrix not it's inv
set <- function(y){
x <<- y
inv <<- NULL
}
get <- function() x
## setting the inverse of the matrix
setinv <- function(solve) inv <<- solve
getinv <- function() inv
list(set=set, get=get,setinv=setinv, getinv=getinv)
}
## If the same matrix is supplied, we will look up the cache and retrieve
## the value of inverse from the cache
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x["getinv"]
if(!is.null(inv)){
message("getting cached data")
return(inv)
}
data <- x["get"]
inv <- solve(x,...)
x$setinv(inv)
inv
}
cacheSolve(matrix(c(1:4,2,2)))
cacheSolve(matrix(c(1:4,2,2)))
makeCacheMatrix(matrix(c(1:4,2,2)))
cacheSolve(matrix(c(1:4,2,2)))
x
y
x <- matrix(c(1:4),2,2)
makeCacheMatrix(x)
x$get()
x["get"]
a <- makeCacheMatrix(x)
a['get']
a['getinv']
x
setinv <- function(solve) inv <- solve
setinv(x)
setinv <- function(x) inv <- solve(x)
setinv(x)
x
setinv <- function(x) inv <<- solve(x)
setinv(x)
x["getinv"]
x
inv <- x["getinv"]
inv
inv <- x$getinv()
inv <- x$ getinv()
inv <- x[getinv]
## Put comments here that give an overall description of what your
## functions do
## creating the special matrix whose inverse will be cached
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
##set is just setting value for the matrix not it's inv
set <- function(y){
x <<- y
inv <<- NULL
}
get <- function() x
## setting the inverse of the matrix
setinv <- function(solve) inv <<- solve
getinv <- function() inv
list(set=set, get=get,setinv=setinv, getinv=getinv)
}
## If the same matrix is supplied, we will look up the cache and retrieve
## the value of inverse from the cache
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x["getinv"]
if(!is.null(inv)){
message("getting cached data")
return(inv)
}
data <- x["get"]
inv <- solve(x,...)
x[setinv(inv)]
inv
}
x
makeCacheMatrix(x)
cacheSolve(x)
## Put comments here that give an overall description of what your
## functions do
## creating the special matrix whose inverse will be cached
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
##set is just setting value for the matrix not it's inv
set <- function(y){
x <<- y
inv <<- NULL
}
get <- function() x
## setting the inverse of the matrix
setinv <- function(solve) inv <<- solve
getinv <- function() inv
list(set=set, get=get,setinv=setinv, getinv=getinv)
}
## If the same matrix is supplied, we will look up the cache and retrieve
## the value of inverse from the cache
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x_$getinv()
if(!is.null(inv)){
message("getting cached data")
return(inv)
}
data <- x_$get()
inv <- solve(x,...)
x_$setinv(inv)
inv
}
makeCacheMatrix(x)
cacheSolve(x)
## Put comments here that give an overall description of what your
## functions do
## creating the special matrix whose inverse will be cached
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
##set is just setting value for the matrix not it's inv
set <- function(y){
x <<- y
inv <<- NULL
}
get <- function() x
## setting the inverse of the matrix
setinv <- function(solve) inv <<- solve
getinv <- function() inv
list(set=set, get=get,setinv=setinv, getinv=getinv)
}
## If the same matrix is supplied, we will look up the cache and retrieve
## the value of inverse from the cache
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x[getinv()]
if(!is.null(inv)){
message("getting cached data")
return(inv)
}
data <- x[get()]
inv <- solve(x,...)
x[setinv(inv)]
inv
}
makeCacheMatrix(x)
cacheSolve(x)
y <- cacheSolve(x)
y <- makeCacheMatrix(x)
cacheSolve(y)
## Put comments here that give an overall description of what your
## functions do
## creating the special matrix whose inverse will be cached
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
##set is just setting value for the matrix not it's inv
set <- function(y){
x <<- y
inv <<- NULL
}
get <- function() x
## setting the inverse of the matrix
setinv <- function(solve) inv <<- solve
getinv <- function() inv
list(set=set, get=get,setinv=setinv, getinv=getinv)
}
## If the same matrix is supplied, we will look up the cache and retrieve
## the value of inverse from the cache
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x["getinv"]
if(!is.null(inv)){
message("getting cached data")
return(inv)
}
data <- x["get"]
inv <- solve(x,...)
x["setinv(inv)"]
inv
}
cacheSolve(y)
str(x)
str(cacheSolve)
library("datasets")
data(iris)
str(iris)
split(iris, iris$species)
subset(iris,iris$species)
split(iris, iris$Species)
rnorm(4,1,2)
x <- rnorm(10)
x
set.seed(1)
rnorm(5)
set.seed(1)
rnorm(5)
rpois(10,1)
x <- 1,2,3,4
x <- c(1,2,3,4)
y <- c(4,3,2,1)
plot(z,y)
plot(x,y)
sample(1:10,4)
set.seed(1)
rpois(5,2)
?ppois
set.seed(10)
x <- rep(0:1, each=5)
e <- rnorm(10,0,20)
y <- 0.5 + 2*x + e
?rep
x
e
plot(x,y)
?rbinom
library(datasets)
Rprof()
fit <- lm(y-x1+x2)
y = 2
x1=1
x2=3
fit <- lm(y-x1+x2)
Rprof(NULL)
simple <- function(){
y = 2
x1 = 1
x2 = 3
library(datasets)
Rprof()
fit <- lm(y ~ x1 + x2)
Rprof(NULL)
}
simple()
install.packages("swirl")
library(swirl)
swirl()
5 + 7
x <- 5 + 7
x
y = x - 3
y <- x - 3
y
z <- c(1.1,9,3.14)
?c
z
c(z,555,z)
z  * 2 + 100
my_sqrt <- sqrt(z-1)
my_sqrt
my_div <- z/my_sqrt
my_div
c(1,2,3,4) + c(0,10)
c(1,2,3,4) + c(0,10,100)
z  * 2 + 100
z  * 2 + 1000
my_div
seq(2,100,4)
subject <- c("John Smith","Mary Smith", "Harry Smith")
time <- c(1,1,1)
age <- c(33,31,3)
weight <-c(75,70,10)
height <- c(2,1.5,1)
smiths <- data.frame
rm(smiths)
smiths <- data.frame()
smiths <- cbind(subject)
smiths
smiths <- cbind(time)
smiths
rm(smiths)
smiths <- data.frame()
smiths <- cbind(subject,time,age,weight, height)
smiths
smiths$subject
rm(smiths)
class(subject)
smiths <- cbind(as.vector(subject),as.vector(time), as.vector(age),as.vector(weight),as.vector(height))
cbind
smiths
names(smiths) <- c("subjects","time","age","weight","height")
smiths
rm(smiths)
data.frame(subject,time,age,weight,height)
smiths <- data.frame(subject,time,age,weight,height)
melt(smiths, id=c(subject,time), measured=c("age","weight","height"))
library(reshape2)
melt(smiths, id=c(subject,time), measured=c("age","weight","height"))
smiths <- data.frame(subject,time,age,weight,height)
melt(smiths, id=c(subject,time), measured=c("age","weight","height"))
melt(smiths, id=c("subject","time"), measured=c("age","weight","height"))
molten_smiths <- melt(smiths, id=c("subject","time"), measured=c("age","weight","height"))
molten_smiths
library(data.table)
molten_smiths <- data.table(molten_smiths)
molten_smiths
molten_smiths$age
molten_smiths$variable
molten_smiths$variable$age
molten_smiths$variable
smiths[1:2]
smiths[1:2,]
smiths[,1:2]
class(molten_smiths)
smiths$'John Smith'
cast(smiths,time+subject~variable)
dcast(smiths,time+subject~variable)
dcast(smiths,value.var = c(age,weight,height))
dcast.data.table(molten_smiths,subject~time)
dcast.data.table(molten_smiths,subject~time,value.var=c(age,height,weight))
dcast.data.table(molten_smiths,subject~time,value.var=c("age","height","weight"))
dcast.data.table(molten_smiths,subject~time,value.var=age
)
dcast.data.table(molten_smiths,subject~time)
smiths
molten_smiths
dcast.data.table(molten_smiths,subject~time,value.var = molten_smiths$variable)
dcast.data.table(molten_smiths,subject~time,value.var = "variable"")
)
e
)
molten_smiths
library(reshape2)
library(data.table)
dcast.data.table(molten_smiths,subject~time,value.var = "variable")
molten_smiths
dcast.data.table(molten_smiths,subject~time~variable,value.var = "value")
dcast.data.table(molten_smiths,subject~time,value.var = "value")
dcast.data.table(molten_smiths,subject~variable,value.var = "value")
hist(activity$totalperday)
library(data.table)
activity <- read.csv("activity.csv", header = T)
activity <- data.table(activity)
```
## What is mean total number of steps taken per day?
```{r extracting total activity per day, echo=FALSE}
#Let's calculate the total steps per day
activity[,totalperday:= sum(steps), by=date]
#Let's extract out the individual dates and associate the unique activity with that day
date_activity <- as.data.frame(activity$date)
date_activity <- cbind(date_activity, activity$totalperday)
date_activity <- unique(date_activity)
hist(activity$totalperday)
library(data.table)
activity <- read.csv("activity.csv", header = T)
activity <- data.table(activity)
activity <- read.csv("activity.csv", header = T)
setwd("/Users/pranavmdesai/Documents/Courses/Reproducible Research/Project 1/")
activity <- read.csv("activity.csv", header = T)
activity <- data.table(activity)
activity[,totalperday:= sum(steps), by=date]
#Let's extract out the individual dates and associate the unique activity with that day
date_activity <- as.data.frame(activity$date)
date_activity <- cbind(date_activity, activity$totalperday)
date_activity <- unique(date_activity)
hist(activity$totalperday)
